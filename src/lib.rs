/* automatically generated by rust-bindgen 0.68.1 */

#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub use root::{soundtouch::*, TDStretch, uint};

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type __enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __type_identity {
            pub _address: u8,
        }
        pub type __type_identity_type<_Type> = _Type;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_type<_Default> = _Default;
        pub type __detector___is_detected = root::std::false_type;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __new_allocator {
            pub _address: u8,
        }
        pub type __new_allocator_value_type<_Tp> = _Tp;
        pub type __new_allocator_size_type = usize;
        pub type __new_allocator_difference_type = isize;
        pub type __new_allocator_pointer<_Tp> = *mut _Tp;
        pub type __new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type __new_allocator_reference<_Tp> = *mut _Tp;
        pub type __new_allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __new_allocator_rebind {
            pub _address: u8,
        }
        pub type __new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type __allocator_base = root::std::__new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = root::std::__undefined;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_elem {
            pub _address: u8,
        }
        pub type __ptr_traits_elem_t = root::std::__ptr_traits_elem;
        pub type __ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
        pub type __ptr_traits_ptr_to_element_type<_Elt> = _Elt;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl {
            pub _address: u8,
        }
        pub type __ptr_traits_impl___diff_t = [u8; 0usize];
        pub type __ptr_traits_impl___rebind = root::std::__type_identity;
        pub type __ptr_traits_impl_pointer<_Ptr> = _Ptr;
        pub type __ptr_traits_impl_element_type<_Elt> = _Elt;
        pub type __ptr_traits_impl_difference_type = root::std::__detected_or_t;
        pub type __ptr_traits_impl_rebind = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = root::std::__type_identity;
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        pub struct vector__Temporary_value<_Tp> {
            pub _M_this: *mut root::std::vector,
            pub _M_storage: root::std::vector__Temporary_value__Storage<_Tp>,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Tp>>,
        }
        #[repr(C)]
        pub union vector__Temporary_value__Storage<_Tp> {
            pub _M_byte: libc::c_uchar,
            pub _M_val: ::core::mem::ManuallyDrop<_Tp>,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Tp>>,
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator___convertible_from = root::std::__enable_if_t;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
    }
    pub type uint = libc::c_uint;
    pub mod soundtouch {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type SAMPLETYPE = f32;
        pub type LONG_SAMPLETYPE = f32;
        #[repr(C)]
        pub struct FIFOSamplePipe__bindgen_vtable(libc::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOSamplePipe {
            pub vtable_: *const FIFOSamplePipe__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOProcessor {
            pub _base: root::soundtouch::FIFOSamplePipe,
            pub output: *mut root::soundtouch::FIFOSamplePipe,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SoundTouch {
            pub _base: root::soundtouch::FIFOProcessor,
            /// Rate transposer class instance
            pub pRateTransposer: *mut root::RateTransposer,
            /// Time-stretch class instance
            pub pTDStretch: *mut root::TDStretch,
            /// Virtual rate parameter. Effective rate & tempo are calculated from these parameters.
            pub virtualRate: f64,
            /// Virtual tempo parameter. Effective rate & tempo are calculated from these parameters.
            pub virtualTempo: f64,
            /// Virtual pitch parameter. Effective rate & tempo are calculated from these parameters.
            pub virtualPitch: f64,
            /// Flag: Has sample rate been set?
            pub bSrateSet: bool,
            /// Accumulator for how many samples in total will be expected as output vs. samples put in,
            /// considering current processing settings.
            pub samplesExpectedOut: f64,
            /// Accumulator for how many samples in total have been read out from the processing so far
            pub samplesOutput: libc::c_long,
            /// Number of channels
            pub channels: root::uint,
            /// Effective `rate` value calculated from `virtualRate`, `virtualTempo` and `virtualPitch`
            pub rate: f64,
            /// Effective `tempo` value calculated from `virtualRate`, `virtualTempo` and `virtualPitch`
            pub tempo: f64,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch16getVersionStringEv"]
            pub fn SoundTouch_getVersionString() -> *const libc::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch12getVersionIdEv"]
            pub fn SoundTouch_getVersionId() -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch7setRateEd"]
            pub fn SoundTouch_setRate(this: *mut root::soundtouch::SoundTouch, newRate: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch8setTempoEd"]
            pub fn SoundTouch_setTempo(this: *mut root::soundtouch::SoundTouch, newTempo: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch13setRateChangeEd"]
            pub fn SoundTouch_setRateChange(this: *mut root::soundtouch::SoundTouch, newRate: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch14setTempoChangeEd"]
            pub fn SoundTouch_setTempoChange(
                this: *mut root::soundtouch::SoundTouch,
                newTempo: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch8setPitchEd"]
            pub fn SoundTouch_setPitch(this: *mut root::soundtouch::SoundTouch, newPitch: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch15setPitchOctavesEd"]
            pub fn SoundTouch_setPitchOctaves(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch17setPitchSemiTonesEi"]
            pub fn SoundTouch_setPitchSemiTones(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch17setPitchSemiTonesEd"]
            pub fn SoundTouch_setPitchSemiTones1(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch11setChannelsEj"]
            pub fn SoundTouch_setChannels(
                this: *mut root::soundtouch::SoundTouch,
                numChannels: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch13setSampleRateEj"]
            pub fn SoundTouch_setSampleRate(
                this: *mut root::soundtouch::SoundTouch,
                srate: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch25getInputOutputSampleRatioEv"]
            pub fn SoundTouch_getInputOutputSampleRatio(
                this: *mut root::soundtouch::SoundTouch,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch5flushEv"]
            pub fn SoundTouch_flush(this: *mut root::soundtouch::SoundTouch);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch10setSettingEii"]
            pub fn SoundTouch_setSetting(
                this: *mut root::soundtouch::SoundTouch,
                settingId: libc::c_int,
                value: libc::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10soundtouch10SoundTouch10getSettingEi"]
            pub fn SoundTouch_getSetting(
                this: *const root::soundtouch::SoundTouch,
                settingId: libc::c_int,
            ) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouchC1Ev"]
            pub fn SoundTouch_SoundTouch(this: *mut root::soundtouch::SoundTouch);
        }
        impl SoundTouch {
            #[inline]
            pub unsafe fn getVersionString() -> *const libc::c_char {
                SoundTouch_getVersionString()
            }
            #[inline]
            pub unsafe fn getVersionId() -> root::uint {
                SoundTouch_getVersionId()
            }
            #[inline]
            pub unsafe fn setRate(&mut self, newRate: f64) {
                SoundTouch_setRate(self, newRate)
            }
            #[inline]
            pub unsafe fn setTempo(&mut self, newTempo: f64) {
                SoundTouch_setTempo(self, newTempo)
            }
            #[inline]
            pub unsafe fn setRateChange(&mut self, newRate: f64) {
                SoundTouch_setRateChange(self, newRate)
            }
            #[inline]
            pub unsafe fn setTempoChange(&mut self, newTempo: f64) {
                SoundTouch_setTempoChange(self, newTempo)
            }
            #[inline]
            pub unsafe fn setPitch(&mut self, newPitch: f64) {
                SoundTouch_setPitch(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchOctaves(&mut self, newPitch: f64) {
                SoundTouch_setPitchOctaves(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchSemiTones(&mut self, newPitch: libc::c_int) {
                SoundTouch_setPitchSemiTones(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchSemiTones1(&mut self, newPitch: f64) {
                SoundTouch_setPitchSemiTones1(self, newPitch)
            }
            #[inline]
            pub unsafe fn setChannels(&mut self, numChannels: root::uint) {
                SoundTouch_setChannels(self, numChannels)
            }
            #[inline]
            pub unsafe fn setSampleRate(&mut self, srate: root::uint) {
                SoundTouch_setSampleRate(self, srate)
            }
            #[inline]
            pub unsafe fn getInputOutputSampleRatio(&mut self) -> f64 {
                SoundTouch_getInputOutputSampleRatio(self)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                SoundTouch_flush(self)
            }
            #[inline]
            pub unsafe fn setSetting(
                &mut self,
                settingId: libc::c_int,
                value: libc::c_int,
            ) -> bool {
                SoundTouch_setSetting(self, settingId, value)
            }
            #[inline]
            pub unsafe fn getSetting(&self, settingId: libc::c_int) -> libc::c_int {
                SoundTouch_getSetting(self, settingId)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                SoundTouch_SoundTouch(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouchD1Ev"]
            pub fn SoundTouch_SoundTouch_destructor(this: *mut root::soundtouch::SoundTouch);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch10putSamplesEPKfj"]
            pub fn SoundTouch_putSamples(
                this: *mut libc::c_void,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch14receiveSamplesEPfj"]
            pub fn SoundTouch_receiveSamples(
                this: *mut libc::c_void,
                output: *mut root::soundtouch::SAMPLETYPE,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch14receiveSamplesEj"]
            pub fn SoundTouch_receiveSamples1(
                this: *mut libc::c_void,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch10SoundTouch5clearEv"]
            pub fn SoundTouch_clear(this: *mut libc::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10soundtouch10SoundTouch21numUnprocessedSamplesEv"]
            pub fn SoundTouch_numUnprocessedSamples(this: *mut libc::c_void) -> root::uint;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOSampleBuffer {
            pub _base: root::soundtouch::FIFOSamplePipe,
            /// Sample buffer.
            pub buffer: *mut root::soundtouch::SAMPLETYPE,
            /// Raw unaligned buffer memory. 'buffer' is made aligned by pointing it to first
            /// 16-byte aligned location of this buffer
            pub bufferUnaligned: *mut root::soundtouch::SAMPLETYPE,
            /// Sample buffer size in bytes
            pub sizeInBytes: root::uint,
            /// How many samples are currently in buffer.
            pub samplesInBuffer: root::uint,
            /// Channels, 1=mono, 2=stereo.
            pub channels: root::uint,
            /// Current position pointer to the buffer. This pointer is increased when samples are 
            /// removed from the pipe so that it's necessary to actually rewind buffer (move data)
            /// only new data when is put to the pipe.
            pub bufferPos: root::uint,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer6ptrEndEj"]
            pub fn FIFOSampleBuffer_ptrEnd(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                slackCapacity: root::uint,
            ) -> *mut root::soundtouch::SAMPLETYPE;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer11setChannelsEi"]
            pub fn FIFOSampleBuffer_setChannels(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                numChannels: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer9addSilentEj"]
            pub fn FIFOSampleBuffer_addSilent(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                nSamples: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBufferC1Ei"]
            pub fn FIFOSampleBuffer_FIFOSampleBuffer(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                numChannels: libc::c_int,
            );
        }
        impl FIFOSampleBuffer {
            #[inline]
            pub unsafe fn ptrEnd(
                &mut self,
                slackCapacity: root::uint,
            ) -> *mut root::soundtouch::SAMPLETYPE {
                FIFOSampleBuffer_ptrEnd(self, slackCapacity)
            }
            #[inline]
            pub unsafe fn setChannels(&mut self, numChannels: libc::c_int) {
                FIFOSampleBuffer_setChannels(self, numChannels)
            }
            #[inline]
            pub unsafe fn addSilent(&mut self, nSamples: root::uint) {
                FIFOSampleBuffer_addSilent(self, nSamples)
            }
            #[inline]
            pub unsafe fn new(numChannels: libc::c_int) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                FIFOSampleBuffer_FIFOSampleBuffer(__bindgen_tmp.as_mut_ptr(), numChannels);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBufferD1Ev"]
            pub fn FIFOSampleBuffer_FIFOSampleBuffer_destructor(
                this: *mut root::soundtouch::FIFOSampleBuffer,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer8ptrBeginEv"]
            pub fn FIFOSampleBuffer_ptrBegin(
                this: *mut libc::c_void,
            ) -> *mut root::soundtouch::SAMPLETYPE;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer10putSamplesEPKfj"]
            pub fn FIFOSampleBuffer_putSamples(
                this: *mut libc::c_void,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer10putSamplesEj"]
            pub fn FIFOSampleBuffer_putSamples1(this: *mut libc::c_void, numSamples: root::uint);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer14receiveSamplesEPfj"]
            pub fn FIFOSampleBuffer_receiveSamples(
                this: *mut libc::c_void,
                output: *mut root::soundtouch::SAMPLETYPE,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer14receiveSamplesEj"]
            pub fn FIFOSampleBuffer_receiveSamples1(
                this: *mut libc::c_void,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10soundtouch16FIFOSampleBuffer10numSamplesEv"]
            pub fn FIFOSampleBuffer_numSamples(this: *mut libc::c_void) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK10soundtouch16FIFOSampleBuffer7isEmptyEv"]
            pub fn FIFOSampleBuffer_isEmpty(this: *mut libc::c_void) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer5clearEv"]
            pub fn FIFOSampleBuffer_clear(this: *mut libc::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch16FIFOSampleBuffer21adjustAmountOfSamplesEj"]
            pub fn FIFOSampleBuffer_adjustAmountOfSamples(
                this: *mut libc::c_void,
                numSamples: root::uint,
            ) -> root::uint;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BEAT {
            pub pos: f32,
            pub strength: f32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IIR2_filter {
            pub coeffs: [f64; 5usize],
            pub prev: [f64; 5usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch11IIR2_filter6updateEf"]
            pub fn IIR2_filter_update(this: *mut root::soundtouch::IIR2_filter, x: f32) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch11IIR2_filterC1EPKd"]
            pub fn IIR2_filter_IIR2_filter(
                this: *mut root::soundtouch::IIR2_filter,
                lpf_coeffs: *const f64,
            );
        }
        impl IIR2_filter {
            #[inline]
            pub unsafe fn update(&mut self, x: f32) -> f32 {
                IIR2_filter_update(self, x)
            }
            #[inline]
            pub unsafe fn new(lpf_coeffs: *const f64) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                IIR2_filter_IIR2_filter(__bindgen_tmp.as_mut_ptr(), lpf_coeffs);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct BPMDetect__bindgen_vtable(libc::c_void);
        #[repr(C)]
        pub struct BPMDetect {
            pub vtable_: *const BPMDetect__bindgen_vtable,
	        /// Auto-correlation accumulator bins.
            pub xcorr: *mut f32,
            /// Sample average counter.
            pub decimateCount: libc::c_int,
	        /// Sample average accumulator for FIFO-like decimation.
            pub decimateSum: root::soundtouch::LONG_SAMPLETYPE,
            /// Decimate sound by this coefficient to reach approx. 500 Hz.
            pub decimateBy: libc::c_int,
            /// Auto-correlation window length.
            pub windowLen: libc::c_int,
            /// Number of channels (1 = mono, 2 = stereo).
            pub channels: libc::c_int,
            /// Sample rate.
            pub sampleRate: libc::c_int,
	        /// Beginning of auto-correlation window: Autocorrelation isn't being updated for
            /// the first these many correlation bins.
            pub windowStart: libc::c_int,
	        /// Window functions for data preconditioning.
            pub hamw: *mut f32,
            pub hamw2: *mut f32,
            pub pos: libc::c_int,
            pub peakPos: libc::c_int,
            pub beatcorr_ringbuffpos: libc::c_int,
            pub init_scaler: libc::c_int,
            pub peakVal: f32,
            pub beatcorr_ringbuff: *mut f32,
	        /// FIFO-buffer for decimated processing samples.
            pub buffer: *mut root::soundtouch::FIFOSampleBuffer,
	        /// Collection of detected beat positions
            pub beats: root::std::vector,
            /// 2nd order low-pass-filter
            pub beat_lpf: root::soundtouch::IIR2_filter,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect11updateXCorrEi"]
            pub fn BPMDetect_updateXCorr(
                this: *mut root::soundtouch::BPMDetect,
                process_samples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect8decimateEPfPKfi"]
            pub fn BPMDetect_decimate(
                this: *mut root::soundtouch::BPMDetect,
                dest: *mut root::soundtouch::SAMPLETYPE,
                src: *const root::soundtouch::SAMPLETYPE,
                numsamples: libc::c_int,
            ) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect12calcEnvelopeEPfi"]
            pub fn BPMDetect_calcEnvelope(
                this: *mut root::soundtouch::BPMDetect,
                samples: *mut root::soundtouch::SAMPLETYPE,
                numsamples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect10removeBiasEv"]
            pub fn BPMDetect_removeBias(this: *mut root::soundtouch::BPMDetect);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect13updateBeatPosEi"]
            pub fn BPMDetect_updateBeatPos(
                this: *mut root::soundtouch::BPMDetect,
                process_samples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect12inputSamplesEPKfi"]
            pub fn BPMDetect_inputSamples(
                this: *mut root::soundtouch::BPMDetect,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect6getBpmEv"]
            pub fn BPMDetect_getBpm(this: *mut root::soundtouch::BPMDetect) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetect8getBeatsEPfS1_i"]
            pub fn BPMDetect_getBeats(
                this: *mut root::soundtouch::BPMDetect,
                pos: *mut f32,
                strength: *mut f32,
                max_num: libc::c_int,
            ) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetectC1Eii"]
            pub fn BPMDetect_BPMDetect(
                this: *mut root::soundtouch::BPMDetect,
                numChannels: libc::c_int,
                sampleRate: libc::c_int,
            );
        }
        impl BPMDetect {
            #[inline]
            pub unsafe fn updateXCorr(&mut self, process_samples: libc::c_int) {
                BPMDetect_updateXCorr(self, process_samples)
            }
            #[inline]
            pub unsafe fn decimate(
                &mut self,
                dest: *mut root::soundtouch::SAMPLETYPE,
                src: *const root::soundtouch::SAMPLETYPE,
                numsamples: libc::c_int,
            ) -> libc::c_int {
                BPMDetect_decimate(self, dest, src, numsamples)
            }
            #[inline]
            pub unsafe fn calcEnvelope(
                &mut self,
                samples: *mut root::soundtouch::SAMPLETYPE,
                numsamples: libc::c_int,
            ) {
                BPMDetect_calcEnvelope(self, samples, numsamples)
            }
            #[inline]
            pub unsafe fn removeBias(&mut self) {
                BPMDetect_removeBias(self)
            }
            #[inline]
            pub unsafe fn updateBeatPos(&mut self, process_samples: libc::c_int) {
                BPMDetect_updateBeatPos(self, process_samples)
            }
            #[inline]
            pub unsafe fn inputSamples(
                &mut self,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: libc::c_int,
            ) {
                BPMDetect_inputSamples(self, samples, numSamples)
            }
            #[inline]
            pub unsafe fn getBpm(&mut self) -> f32 {
                BPMDetect_getBpm(self)
            }
            #[inline]
            pub unsafe fn getBeats(
                &mut self,
                pos: *mut f32,
                strength: *mut f32,
                max_num: libc::c_int,
            ) -> libc::c_int {
                BPMDetect_getBeats(self, pos, strength, max_num)
            }
            #[inline]
            pub unsafe fn new(numChannels: libc::c_int, sampleRate: libc::c_int) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                BPMDetect_BPMDetect(__bindgen_tmp.as_mut_ptr(), numChannels, sampleRate);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10soundtouch9BPMDetectD1Ev"]
            pub fn BPMDetect_BPMDetect_destructor(this: *mut root::soundtouch::BPMDetect);
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_2 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RateTransposer {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct TDStretch {
        pub _address: u8,
    }
}
